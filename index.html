<!doctype html>
<html lang="zh-CN">
<head>
<meta charset="utf-8">
<title>方案 C · 正确解锁节奏版</title>
<meta name="viewport" content="width=device-width,initial-scale=1">
<style>
body{margin:0;background:#0b0c0f;color:#e9eef8;font-family:system-ui}
.wrap{max-width:960px;margin:24px auto;padding:0 14px}
.btn{padding:10px 14px;border-radius:12px;border:1px solid #333;background:#111;color:#eee;font-weight:700;cursor:pointer}
.btn:hover{background:#1a1a1a}
.btn.red{border-color:#553;color:#fbb}
.panel{border:1px solid #222;background:#111;border-radius:16px;padding:16px;margin-top:12px}
.big{font-size:36px;font-weight:900;text-align:center;padding:18px;border-radius:14px}
.big.ok{background:#123;color:#2ee08a}
.big.no{background:#200;color:#ff6b6b}
.row{display:flex;gap:10px;flex-wrap:wrap}
.mono{font-family:ui-monospace,Consolas,monospace}
.small{font-size:13px;color:#aaa}
.box{border:1px solid #222;border-radius:12px;padding:12px;margin-top:10px}
</style>
</head>
<body>
<div class="wrap">
<h2>方案 C · 正确解锁节奏</h2>
<div class="row">
  <button class="btn" onclick="add('B')">录入 B</button>
  <button class="btn" onclick="add('P')">录入 P</button>
  <button class="btn" onclick="undo()">撤销</button>
  <button class="btn red" onclick="resetAll()">清空</button>
</div>
<div class="panel">
  <div id="banner" class="big no">现在：不要动</div>
  <div class="small" id="reason" style="margin-top:10px"></div>
</div>
<div class="box">
  <div class="small">最近 6 把（只算 B / P）：</div>
  <div class="mono" id="recent">不足</div>
</div>
<div class="box">
  <div class="small">完整历史：</div>
  <div class="mono" id="history">（空）</div>
</div>
</div>

<script>
const SUB_WINDOW = 6;
const THRESHOLD = 4;
let history = [];
let used = false;                 // 已经下注过一次
let lockFramePassed = false;      // 是否已经跨过“下注那一把”
let prevRecentKey = "";

// ✅ 防连播、防定时器堆积
let lastSpeech = "";
let pendingSpeakTimer = null;

// ✅ 新增：同一 recentKey 的下注播报只触发一次
let lastBetKey = "";
let lastBetDir = "";

/* ===== 女声 ===== */
let voice=null;
function pickVoice(){
  const v=speechSynthesis.getVoices();
  voice=v.find(x=>/zh/i.test(x.lang))||null;
}
pickVoice();
speechSynthesis.onvoiceschanged=pickVoice;

function speak(t){
  if(!t) return;

  // ✅ 同一句不重复播
  if(t === lastSpeech) return;
  lastSpeech = t;

  // ✅ 只有正在说/排队时才 cancel，避免疯狂打断造成“乱叫”
  if (speechSynthesis.speaking || speechSynthesis.pending) {
    speechSynthesis.cancel();
  }

  const u=new SpeechSynthesisUtterance(t);
  if(voice) u.voice=voice;
  speechSynthesis.speak(u);
}

/* ===== 工具 ===== */
function lastBP(){
  return history.filter(x=>x==="B"||x==="P").slice(-SUB_WINDOW);
}
function countBP(a){
  return {b:a.filter(x=>x==="B").length,p:a.filter(x=>x==="P").length};
}

/* ===== 操作 ===== */
function add(x){
  speechSynthesis.resume();
  history.push(x);
  render();
}
function undo(){
  history.pop();
  render();
}
function resetAll(){
  history=[];
  used=false;
  lockFramePassed=false;
  prevRecentKey="";

  // ✅ 清理播报状态/定时器
  lastSpeech="";
  if (pendingSpeakTimer) { clearTimeout(pendingSpeakTimer); pendingSpeakTimer=null; }

  // ✅ 清理下注播报去重
  lastBetKey="";
  lastBetDir="";

  render();
}

/* ===== 核心 ===== */
function render(){
  const banner=document.getElementById("banner");
  const reason=document.getElementById("reason");
  document.getElementById("history").textContent=history.join("")||"（空）";

  const recent=lastBP();
  document.getElementById("recent").textContent=
    recent.length<6?"不足":recent.join("");

  const recentKey=recent.length===6?recent.join(""):"";

  // ✅ 本轮是否刚刚解锁（解锁那一把不立刻再播“下注”）
  let unlockedThisFrame = false;

  // —— 解锁判断（只在下注后的“下一把”）——
  if(used && lockFramePassed && prevRecentKey && recentKey && recentKey!==prevRecentKey){
    speak("结构已解锁");
    used=false;
    lockFramePassed=false;

    unlockedThisFrame = true;  // ✅ 标记
    lastBetKey = recentKey;    // ✅ 防止同一轮马上又触发“下注播报”
  }

  if(recentKey) prevRecentKey=recentKey;

  if(recent.length<6){
    banner.textContent="现在：不要动";
    reason.textContent="数据不足";
    return;
  }

  const {b,p}=countBP(recent);
  let dir=null;
  if(b>=THRESHOLD) dir="B";
  if(p>=THRESHOLD) dir="P";

  if(dir){
    if(!used){
      banner.textContent="可以动："+dir;
      reason.textContent=`最近6把=${recent.join("")}`;

      // ✅ 刚解锁的这一把不播下注（避免“连续叫”）
      // ✅ 同一个 recentKey 只播一次（除非方向变了）
      if(!unlockedThisFrame && (recentKey !== lastBetKey || dir !== lastBetDir)){
        if (pendingSpeakTimer) clearTimeout(pendingSpeakTimer);
        pendingSpeakTimer = setTimeout(()=>{
          speak("可以动，下注 " + dir);
          pendingSpeakTimer = null;
        }, 250);

        lastBetKey = recentKey;
        lastBetDir = dir;
      }

      used=true;
      lockFramePassed=false;   // ⚠️ 刚下注，还不能解锁
    }else{
      banner.textContent="现在：不要动";
      reason.textContent="本结构期已用过一次";
      lockFramePassed=true;    // ✅ 已经跨过下注那一把
    }
  }else{
    banner.textContent="现在：不要动";
    reason.textContent="未达阈值";
  }
}
</script>
</body>
</html>
